name: Avalara Release Sync

on:
  workflow_dispatch: {}
  schedule:
    - cron: '5 * * * *' # optional; remove if you only want manual runs

# Prevent multiple concurrent runs
concurrency:
  group: avalara-automation-sync-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  sync_main:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout fork
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # we need history to fast-forward
          token: ${{ secrets.SYNC_PAT }}

      - name: Configure git
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
      
      - name: Add upstream and fetch latest
        run: |
          # Add upstream remote if it doesn't exist
          if ! git remote get-url upstream >/dev/null 2>&1; then
            git remote add upstream https://github.com/svix/svix-webhooks.git
          fi
          git fetch upstream main
      
      - name: Sync main branch with upstream (preserving avalara workflows)
        run: |
          # Checkout main branch
          git checkout -B main origin/main || git checkout main
          
          # Backup avalara workflow files and custom action
          cp .github/workflows/avalara-release.yml /tmp/avalara-release.yml || true
          
          # Hard reset to upstream main
          git reset --hard upstream/main

          # Restore avalara workflow files and custom action
          cp /tmp/avalara-release.yml .github/workflows/avalara-release.yml || true
          
          git add .github/workflows/avalara-release.yml 
          git commit -m "sync: update main branch from upstream (preserving avalara workflows)" || true
      
      - name: Push automation branch
        run: |
          git push origin main --force
        env:
          GITHUB_TOKEN: ${{ secrets.SYNC_PAT }}

  create_latest_release:
    runs-on: ubuntu-latest
    needs: [sync_main]
    steps:
      - name: Checkout fork
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # we need history to work with tags
          token: ${{ secrets.SYNC_PAT }}

      - name: Configure git
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Add upstream and fetch
        run: |
          # Add upstream remote if it doesn't exist
          if ! git remote get-url upstream >/dev/null 2>&1; then
            git remote add upstream https://github.com/svix/svix-webhooks.git
          fi
          git fetch upstream main
          git fetch --all

      - name: Reset latest-release branch to upstream/main
        run: |
          LATEST_BRANCH_NAME="latest-release"
          
          echo "Resetting $LATEST_BRANCH_NAME branch to upstream/main..."
          
          # Create or checkout branch from upstream/main (will be reset anyway)
          # Using -B forces creation or reset to upstream/main
          git checkout -B "$LATEST_BRANCH_NAME" upstream/main
          
          # Force push the branch (atomic operation - branch now matches upstream/main exactly)
          echo "Force pushing $LATEST_BRANCH_NAME to origin..."
          git push origin "$LATEST_BRANCH_NAME" --force
        env:
          GITHUB_TOKEN: ${{ secrets.SYNC_PAT }}

  verify_latest_release:
    runs-on: ubuntu-latest
    needs: [create_latest_release]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # we need history to work with branches
          token: ${{ secrets.SYNC_PAT }}

      - name: Configure Git user
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Add upstream and fetch latest
        run: |
          # Add upstream remote if it doesn't exist
          if ! git remote get-url upstream >/dev/null 2>&1; then
            git remote add upstream https://github.com/svix/svix-webhooks.git
          fi
          git fetch upstream main
          git fetch --all

      - name: Verify latest-release matches upstream main
        run: |
          echo "=== LATEST-RELEASE VERIFICATION ==="
          echo "Verifying that latest-release branch matches upstream main"
          
          # Check if branches exist
          if ! git show-ref --verify --quiet "refs/remotes/origin/latest-release"; then
            echo "‚ùå ERROR: latest-release branch does not exist"
            exit 1
          fi
          
          if ! git show-ref --verify --quiet "refs/remotes/upstream/main"; then
            echo "‚ùå ERROR: upstream main branch does not exist"
            exit 1
          fi
          
          echo "‚úÖ Both branches exist"
          
          # Get commit SHAs
          LATEST_RELEASE_SHA=$(git rev-parse origin/latest-release)
          UPSTREAM_MAIN_SHA=$(git rev-parse upstream/main)
          
          echo "üìù latest-release commit: $LATEST_RELEASE_SHA"
          echo "üìù upstream main commit: $UPSTREAM_MAIN_SHA"
          
          # Approach 1: Check if latest-release is based on upstream/main (ancestor check)
          echo ""
          echo "üîç Checking commit ancestry..."
          if git merge-base --is-ancestor upstream/main origin/latest-release; then
            echo "‚úÖ latest-release is based on upstream/main (ancestor check passed)"
            ANCESTOR_CHECK=true
          else
            echo "‚ö†Ô∏è  latest-release is not directly based on upstream/main"
            ANCESTOR_CHECK=false
          fi
          
          # Approach 2: Check if tree (content) is identical
          echo ""
          echo "üîç Checking content equivalence..."
          LATEST_RELEASE_TREE=$(git rev-parse origin/latest-release^{tree})
          UPSTREAM_MAIN_TREE=$(git rev-parse upstream/main^{tree})
          
          if [ "$LATEST_RELEASE_TREE" = "$UPSTREAM_MAIN_TREE" ]; then
            echo "‚úÖ Content (tree) is identical between branches"
            TREE_MATCH=true
          else
            echo "‚ö†Ô∏è  Content differs between branches"
            TREE_MATCH=false
            
            # Show what files differ
            echo ""
            echo "üìã Files that differ:"
            git diff --name-status upstream/main...origin/latest-release || true
          fi
          
          # Approach 3: Verify package.json version matches (sanity check)
          echo ""
          echo "üîç Verifying package.json version..."
          LATEST_RELEASE_VERSION=$(git show "origin/latest-release:package.json" 2>/dev/null | grep '"version"' | head -1 | sed 's/.*"version": *"\([^"]*\)".*/\1/' || echo "")
          UPSTREAM_MAIN_VERSION=$(git show "upstream/main:package.json" 2>/dev/null | grep '"version"' | head -1 | sed 's/.*"version": *"\([^"]*\)".*/\1/' || echo "")
          
          if [ -n "$LATEST_RELEASE_VERSION" ] && [ -n "$UPSTREAM_MAIN_VERSION" ]; then
            echo "üì¶ latest-release version: $LATEST_RELEASE_VERSION"
            echo "üì¶ upstream main version: $UPSTREAM_MAIN_VERSION"
            
            if [ "$LATEST_RELEASE_VERSION" = "$UPSTREAM_MAIN_VERSION" ]; then
              echo "‚úÖ Version match"
              VERSION_MATCH=true
            else
              echo "‚ö†Ô∏è  Version mismatch"
              VERSION_MATCH=false
            fi
          else
            echo "‚ö†Ô∏è  Could not extract versions (package.json might not exist)"
            VERSION_MATCH=false
          fi
          
          # Final verdict
          echo ""
          echo "üìä VERIFICATION SUMMARY:"
          echo "  - Ancestor check: $ANCESTOR_CHECK"
          echo "  - Tree/content match: $TREE_MATCH"
          echo "  - Version match: $VERSION_MATCH"
          echo ""
          
          # Pass if either tree matches (content identical) or ancestor check passes with version match
          if [ "$TREE_MATCH" = "true" ]; then
            echo "üéâ VERIFICATION PASSED - latest-release content matches upstream/main!"
            exit 0
          elif [ "$ANCESTOR_CHECK" = "true" ] && [ "$VERSION_MATCH" = "true" ]; then
            echo "üéâ VERIFICATION PASSED - latest-release is based on upstream/main with matching version!"
            exit 0
          else
            echo "‚ùå VERIFICATION FAILED - latest-release does not properly match upstream/main"
            echo ""
            echo "The latest-release branch should match upstream/main content."
            echo "This indicates the create_latest_release process may not have completed correctly."
            exit 1
          fi

